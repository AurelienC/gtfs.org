# GTFS Realtime参考

GTFS Realtime信息让公交机构向消费者提供有关服务中断（车站关闭、线路不运行、重要延误等）、车辆位置和预计到达时间的Realtime信息。

本网站讨论并记录了2.0版本的饲料规范。有效的版本是 "2.0"、"1.0"。

### 术语定义

#### 需要

在GTFS v2.0及以上版本中，"_需要_"一栏描述了生产者必须提供哪些字段才能使过境数据有效并对消费应用程序有意义。

以下数值用于_必填_字段。

*   **需要**。这个字段必须由GTFS饲料生产商提供。
*   **有条件要求**。该字段在某些条件下是必需的，这些条件在字段_描述_中列出。在这些条件之外，该字段是可选的。
*   **可选的**。这个字段是可选的，不要求生产者实施。然而，如果数据在底层的自动车辆定位系统中可用（例如，VehiclePosition`时间戳`），则建议生产者在可能的情况下提供这些可选字段。

_请注意，语义要求没有在GTFS 1.0版本中定义，因此`gtfs_realtime_version`为`1`的馈送可能不符合这些要求（详见[语义要求的建议](https://github.com/google/transit/pull/64)）。_

#### 心数

_Cardinality_表示可以为一个特定字段提供的元素数量，其数值如下。

*   **一**- 可以为这个字段提供一个单一的一元素。这与[协议缓冲区_的必要_和_可选的_](https://developers.google.com/protocol-buffers/docs/proto#simple)卡位相对应。
*   **许多**- 可以为这个字段提供许多元素（0，1，或更多）。这映射到[协议缓冲区](https://developers.google.com/protocol-buffers/docs/proto#simple)的[ _重复_](https://developers.google.com/protocol-buffers/docs/proto#simple)卡位。

始终参考 "_需要_"和 "_描述_"字段，以了解一个字段何时是需要的、有条件的、或可选的。请参考[GTFS-Realtime/proto/GTFS-Realtime.proto">`GTFS`](<https://github.com/google/transit/blob/master/\<glossary variable=>).proto以了解协议缓冲区的cardinality。

#### 协议缓冲区数据类型

以下协议缓冲区的数据类型用于描述进给元素。

*   **消息**。复杂类型
*   **枚举**。固定值的列表

#### 实验性字段

标记为**实验性的**字段是可以改变的，并且尚未被正式纳入规范。**实验性**字段可能会在将来被正式采用。

## 元素索引

*   [馈送信息](#message-feedmessage)
    *   [饲料标题](#message-feedheader)

        *   [增量](#enum-incrementality)

    *   [饲料实体](#message-feedentity)

        *   [行程更新](#message-tripupdate)

            *   [行程描述符](#message-tripdescriptor)

                *   [计划关系](#enum-schedulerelationship-1)

            *   [车辆描述符](#message-vehicledescriptor)

            *   [停止时间更新](#message-stoptimeupdate)

                *   [停止时间事件](#message-stoptimeevent)
                *   [时间关系](#enum-schedulerelationship)
                *   [停顿时间属性](#message-stoptimeproperties)

            *   [行程属性](#message-tripproperties)

        *   [车辆位置](#message-vehicleposition)

            *   [旅程描述符](#message-tripdescriptor)

                *   [时间安排关系](#enum-schedulerelationship-1)

            *   [车辆描述符](#message-vehicledescriptor)

            *   [位置参数](#message-position)

            *   [车辆停靠状态](#enum-vehiclestopstatus)

            *   [拥堵程度](#enum-congestionlevel)

            *   [占用状态](#enum-occupancystatus)

            *   [车厢细节](#message-carriagedetails)

        *   [警报](#message-alert)

            *   [时间范围](#message-timerange)

            *   [实体选择器](#message-entityselector)

                *   [TripDescriptor](#message-tripdescriptor)

                    *   [时间关系](#enum-schedulerelationship-1)

            *   [原因](#enum-cause)

            *   [影响](#enum-effect)

            *   [翻译的字符串](#message-translatedstring)

                *   [翻译](#message-translation)

            *   [严重性等级（SeverityLevel](#enum-severitylevel)

## 讯息

## _消息_FeedMessage

一个Feed消息的内容。流中的每个消息是作为对适当的HTTP GET请求的响应而获得的。Realtime馈送总是与现有的GTFS馈送一起定义。所有的实体ID都是相对于GTFS馈送而解决的。

**领域**

| _**字段名**_ | _**类型**_                          | _**需要**_ | _**心数**_ | _**说明**_                                                   |
| --------- | --------------------------------- | -------- | -------- | ---------------------------------------------------------- |
| **标题**    | [FeedHeader](#message-feedheader) | 需要       | 一        | 关于此饲料和饲料消息的元数据。                                            |
| **实体**    | [FeedEntity](#message-feedentity) | 有条件要求    | 许多       | 反馈的内容。  如果交通系统有实时信息，这个字段必须被提供。  如果这个字段是空的，消费者应假定该系统没有实时信息。 |

## _消息_FeedHeader

关于feed的元数据，包括在feed消息中。

**领域**

| _**字段名**_                 | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                      |
| ------------------------- | -------------------------------------------------------------------------- | -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **gtfs_realtime_version** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 需要       | 一        | 饲料规范的版本。目前的版本是2.0。                                                                                                                                            |
| **递增性**                   | [增量](#enum-incrementality)                                                 | 需要       | 一        |                                                                                                                                                               |
| **时间戳**                   | [uint64](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 这个时间戳标识了这个feed的内容被创建的时刻（在服务器时间）。在POSIX时间（即从1970年1月1日00:00:00 UTC开始的秒数）。为了避免产生和消费Realtime信息的系统之间的时间偏差，强烈建议从时间服务器中获得时间戳。使用第3层甚至更低层的服务器是完全可以接受的，因为几秒钟的时间差是可以容忍的。 |

## _enum_Incrementality

确定当前获取的数据是否是增量的。

*   **FULL_DATASET**：该信息源更新将覆盖该信息源的所有先前的Realtime信息。因此，该更新预计将提供所有已知Realtime信息的完整快照。
*   **DIFFERENTIAL**：目前，这种模式是**不被支持的**，对于使用这种模式的饲料，行为也**没有被指定**。在[GTFS-realtime">GTFS Realtime](<https://groups.google.com/group/\<glossary variable=>)邮件列表中，有关于完全指定DIFFERENTIAL模式的行为的讨论，当这些讨论最终完成时，文档将被更新。

**价值**

| _**价值**_         |
| ---------------- |
| **FULL_DATASET** |
| **二次方**          |

## _消息_FeedEntity

转运资料中的一个实体的定义（或更新）。如果该实体没有被删除，'trip_update'、'vehicle'、'alert'和'shape'中的一个字段应该被填入。

**领域**

| _**字段名**_      | _**类型**_                                                                 | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                              |
| -------------- | ------------------------------------------------------------------------ | -------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **id**         | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)    | 需要       | 一        | 这个实体的feed-unique标识符。这些标识符只用于提供增量支持。饲料引用的实际实体必须由明确的选择器来指定（更多信息见下面的EntitySelector）。                                                                     |
| **is_deleted** | [bool](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 这个实体是否要被删除。只应提供给增量为DIFFERENTIAL的馈送 - 这个字段不应该提供给增量为FULL_DATASET的馈送。                                                                                    |
| **行程_更新**      | [TripUpdate](#message-tripupdate)                                        | 有条件要求    | 一        | 关于一个旅程的Realtime出发延迟的数据。  必须提供至少一个字段trip_update, vehicle, alert, 或 shape - 所有这些字段不能是空的.                                                                |
| **车辆**         | [车辆位置](#message-vehicleposition)                                         | 有条件要求    | 一        | 关于车辆的Realtime位置的数据.必须提供至少一个字段trip_update, vehicle, alert, 或 shape - 所有这些字段不能为空.                                                                       |
| **警报**         | [警报](#message-alert)                                                     | 有条件要求    | 一        | 关于Realtime警报的数据.必须提供至少一个字段 trip_update, vehicle, alert, 或 shape - 所有这些字段不能为空.                                                                         |
| **形状**         | [形状](#message-shape)                                                     | 有条件要求    | 一        | 关于Realtime添加的形状的数据，例如绕道.至少必须提供一个字段trip_update, vehicle, alert, 或 shape - 所有这些字段不能为空. <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |

## _消息_TripUpdate

Realtime更新车辆在行程中的进展。也请参考[Realtime/trip-updates">行程更新实体](</\<glossary variable=>)的一般讨论。

根据ScheduleRelationship的值，一个TripUpdate可以指定。

*   一个沿着Schedule进行的旅程。
*   一个沿着路线进行但没有固定Schedule的旅程。
*   一个被添加或删除的行程，与Schedule有关。
*   一个新的旅程，是静态GTFS中现有旅程的副本。它将在TripProperties中指定的服务日期和时间运行。

更新可以是未来的，预测的到达/离开事件，或已经发生的过去的事件。在大多数情况下，关于过去事件的信息是一个测量值，因此它的不确定性值被推荐为0。如果一个更新的不确定性不是0，要么该更新是对一个尚未完成的行程的近似预测，要么测量不精确，要么该更新是对过去的预测，但在事件发生后没有得到验证。

如果一辆车在同一区块内提供多个行程（关于行程和区块的更多信息，请参考[Schedule/reference/#tripstxt">GTFS trips.txt](</\<glossary variable=>)）。

*   馈送应该包括该车辆当前服务的行程的TripUpdate。如果生产者对这些未来行程的预测质量有信心，我们鼓励生产者在该车辆的区块中包括当前行程之后的一个或多个行程的TripUpdates。包括同一车辆的多个TripUpdates，可以避免车辆从一个行程过渡到另一个行程时对乘客的预测 "突然出现"，也可以让乘客提前知道影响下游行程的延误（例如，当已知的延误超过了行程之间的计划停留时间）。
*   各自的TripUpdate实体不需要按照它们在区块中安排的相同顺序添加到馈送中。例如，如果有`行程编号`为1，2和3的行程都属于一个区块，并且车辆行驶了行程1，然后是行程2，然后是行程3，那么`行程_更新`实体可以以任何顺序出现 - 例如，允许添加行程2，然后是行程1，然后是行程3。

注意，更新可以描述一个已经完成的旅程.为此，只需提供一个旅程最后一站的更新即可。如果到达最后一站的时间是过去的，客户端将得出结论，整个行程是过去的（有可能，尽管不重要，也可以提供前面几站的更新）。这个选项对于一个已经提前完成Schedule行程来说是最有意义的，但是根据Schedule，这个行程在当前时间仍在进行中。移除这个行程的更新可能会使客户端认为这个行程仍在进行中。注意信息提供者允许，但不是必须，清除过去的更新 - 这是一个实际有用的情况。

**领域**

| _**字段名**_  | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                                                                                               |
| ---------- | -------------------------------------------------------------------------- | -------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **行程**     | [TripDescriptor](#message-tripdescriptor)                                  | 需要       | 一        | 这个消息所适用的行程。每个实际的行程实例最多可以有一个TripUpdate实体。如果没有，意味着没有可用的预测信息。这确实 _不是_意味着该行程正在按照Schedule进行。                                                                                                                                                                                                                                                |
| **车辆**     | [车辆描述符](#message-vehicledescriptor)                                        | 可选的      | 一        | 关于为这个行程服务的车辆的额外信息。                                                                                                                                                                                                                                                                                                                     |
| **停止时间更新** | [停止时间更新](#message-stoptimeupdate)                                          | 有条件要求    | 许多       | 对行程的停止时间的更新（包括未来的，即预测的，以及在某些情况下，过去的，即那些已经发生的）。这些更新必须按照stop_sequence排序，并且适用于旅行的所有后续站点，直到下一个指定的stop_time_update。  至少必须提供一个行程的stop_time_update，除非行程.schedule_relationship是CANCELED或DUPLICATED - 如果行程被取消，不需要提供stop_time_updates。如果行程是重复的，可以提供stop_time_updates来表示新行程的实时信息。                                                                 |
| **时间戳**    | [uint64](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 测量车辆实时进展的最近时刻，以估计未来的StopTimes。当提供过去的StopTimes时，到达/离开的时间可能比这个值早。以POSIX时间（即从1970年1月1日00:00:00 UTC开始的秒数）。                                                                                                                                                                                                                                 |
| **延迟**     | [int32](https://developers.google.com/protocol-buffers/docs/proto#scalar)  | 可选的      | 一        | 该行程的当前Schedule偏差。只有当预测是相对于GTFS中的一些现有Schedule给出时，才应指定延迟。<br/>延迟（以秒为单位）可以是正数（意味着车辆迟到）或负数（意味着车辆比Schedule提前）。延迟为0意味着车辆完全准时。<br/>StopTimeUpdates中的延迟信息优先于行程级别的延迟信息，这样，行程级别的延迟只传播到行程中的下一站，并指定StopTimeUpdate延迟值。<br/>强烈建议信息提供者提供TripUpdate.timestamp值，表明延迟值最后更新的时间，以评估数据的新鲜度。<br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |
| **行程_属性**  | [旅程属性（TripProperties](#message-tripproperties)                             | 可选的      | 一        | 提供行程的最新属性。 <br/><br/>**注意事项。**这个消息仍然是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                                                                                                          |

## _消息_StopTimeEvent

单个预测事件（到达或离开）的时间信息。时间由延迟和/或估计时间，以及不确定性组成。

*   当预测是相对于GTFS中的一些现有Schedule给出时，应该使用延迟。
*   无论是否有一个预测的Schedule，都应该给出时间。如果时间和延迟都被指定，时间将被优先考虑（尽管通常情况下，时间，如果给定的行程，应该等于GTFS中的计划时间+延迟）。

不确定性同样适用于时间和延迟。不确定度大致规定了真实延迟的预期误差（但注意，我们还没有定义其精确的统计意义）。不确定度有可能为0，例如在计算机计时控制下驱动的列车。

**领域**

| _**字段名**_ | _**类型**_                                                                  | _**需要**_ | _**心数**_ | _**说明**_                                                                                         |
| --------- | ------------------------------------------------------------------------- | -------- | -------- | ------------------------------------------------------------------------------------------------ |
| **延迟**    | [int32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 延迟（以秒为单位）可以是正数（意味着车辆晚点）或负数（意味着车辆比Schedule提前）。延迟为0意味着车辆完全准时。  在StopTimeEvent中必须提供延迟或时间，这两个字段不能为空。 |
| **时间**    | [int64](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 事件为绝对时间。以POSIX时间（即从1970年1月1日00:00:00 UTC开始的秒数）。在一个StopTimeEvent中必须提供延迟或时间，这两个字段不能为空。             |
| **不确定度**  | [int32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 如果不确定性被省略，它将被解释为未知。要指定一个完全确定的预测，将其不确定性设置为0。                                                      |

## _消息_StopTimeUpdate

对行程中某一站的到达和/或离开事件进行Realtime更新。也请参考[TripDescriptor](#message-tripdescriptor)和[Realtime/trip-updates">行程更新实体](</\<glossary variable=>)文件中关于站点时间更新的一般讨论。

可以为过去和未来的事件提供更新。生产者被允许，尽管不是必须，放弃过去的事件。

更新通过stop_sequence或stop_id与一个特定的站点相联系，因此这些字段中的一个必须被设置。 如果同一个stop_id在一个行程中被访问了多次，那么stop_sequence应该在该行程中的所有stop_id的StopTimeUpdates中提供。

**领域**

| _**字段名**_                | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                |
| ------------------------ | -------------------------------------------------------------------------- | -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **stop_sequence**        | [uint32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 必须与相应的GTFS饲料中的stop_times.txt相同。  stop_stop_sequence或stop_id必须在StopTimeUpdate中提供，这两个字段不能为空。stop_sequence对于多次访问同一个stop_id的旅行是必需的（例如，一个循环），以区分预测是针对哪一站。如果 `StopTimeProperties.assigned_stop_id`已被填入，那么 `stop_sequence`也必须被填入。                              |
| **stop_id**              | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 必须与相应的GTFS饲料中的stops.txt相同。在StopTimeUpdate中必须提供stop_sequence或stop_id，这两个字段不能为空。如果 `StopTimeProperties.assigned_stop_id`被填入，最好省略 `stop_id`而只使用 `stop_sequence`.如果 `StopTimeProperties.assigned_stop_id`和 `stop_id`是弹出的。 `stop_id`必须匹配 `assigned_stop_id`. |
| **到达**                   | [StopTimeEvent](#message-stoptimeevent)                                    | 有条件要求    | 一        | 如果schedule_relationship为空或SCHEDULED，则必须在StopTimeUpdate中提供到达或离开，这两个字段不能为空。  如果schedule_relationship是NO_DATA，到达和离开必须是空的。                                                                                                                                  |
| **出发**                   | [StopTimeEvent](#message-stoptimeevent)                                    | 有条件要求    | 一        | 如果schedule_relationship为空或SCHEDULED，则必须在StopTimeUpdate中提供到达或离开，这两个字段不能为空。  如果schedule_relationship是NO_DATA，到达和离开必须是空的。                                                                                                                                  |
| **出发_占用状态**              | [占用状态](#enum-occupancystatus)                                              | 可选的      | 一        | 车辆从给定的站点出发后，预测的乘客占用状态。如果提供，必须提供stop_sequence。要提供departure_occupancy_status而不提供任何实时到达或离开的预测，请填入这个字段并设置StopTimeUpdate.schedule_relationship = NO_DATA。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                   |
| **计划关系**                 | [时间安排关系](#enum-schedulerelationship)                                       | 可选的      | 一        | 默认的关系是SCHEDULED。                                                                                                                                                                                                                                        |
| **Stop_time_properties** | [停止时间属性](#message-stoptimeproperties)                                      | 可选的      | 一        | 对GTFS stop_times.txt内定义的某些属性进行Realtime更新 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                               |

## _enum_ScheduleRelationship

该停止时间与静态Schedule之间的关系。

**价值**

| _**价值**_    | _**评论**_                                                                                                                                                                                                                                                                                                                                                |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **已安排**     | 车辆正按照其静态停车Schedule行驶，尽管不一定是按照Schedule的时间行驶。这就是 **默认的**行为。必须提供至少一个到达和离开的时间。基于频率的行程GTFS frequencies.txt，精确时间=0）不应该有一个SCHEDULED值，而应该使用UNSCHEDULED。                                                                                                                                                                                                         |
| **跳过**      | 该站被跳过，即车辆不会在这一站停车。到达和离开是可选的。当设置 `SKIPPED`不会传播到同一行程中的后续站点（即，车辆将在行程中的后续站点停车，除非这些站点也有一个 `stop_time_update`与 `schedule_relationship: SKIPPED`).旅程中前一站的延迟 _是否_传播到 `SKIPPED`辆。换句话说，如果一个 `stop_time_update`有一个 `arrival`或 `departure`预测没有为该站之后的一个站点设置 `SKIPPED`后没有设置预测值，那么在该站上游的预测值 `SKIPPED`的上游预测将被传播到该站之后的 `SKIPPED`和行程中的后续站点，直到 `stop_time_update`后面的站点被提供。 |
| **NO_DATA** | 没有为这一站提供数据。它表示没有可用的Realtime时间信息。当设置NO_DATA时，会通过后续的站点传播，所以这是被推荐的指定哪一站没有Realtime时间信息的方式。当NO_DATA被设置时，到达和离开都不应该被提供。                                                                                                                                                                                                                                        |
| **未安排**     | 车辆正在运行一个基于频率的行程GTFS frequencies.txt与exact_times = 0）。这个值不应该用于GTFS frequencies.txt中没有定义的行程，或者GTFS frequencies.txt中确切时间=1的行程。包含在 `stop_time_updates`与 `schedule_relationship: UNSCHEDULED`的旅行也必须设置TripDescriptor `schedule_relationship: UNSCHEDULED` <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                    |

## _消息_StopTimeProperties

Realtime更新在GTFS stop_times.txt中定义的某些属性。

**注意：**这个消息仍然是**试验性的**，可能会有变化。它可能在未来被正式采用。<br/>

**领域**

| _**字段名**_    | _**类型**_                                                              | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ------------ | --------------------------------------------------------------------- | -------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **指派的站点_id** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 支持实时停车分配。指的是一个 `stop_id`在GTFS中定义的 `stops.txt`. <br/>新的 `assigned_stop_id`不应导致终端用户的旅行体验与原来的大不相同。 `stop_id`GTFS车次必须设置行程描述符。 `stop_times.txt`.换句话说，终端用户不应该认为这个新的 `stop_id`如果新站是在没有任何额外背景的情况下出现在应用程序中，则被视为 "不寻常的变化"。例如，这个字段的目的是通过使用一个 `stop_id`属于与GTFS中最初定义的站点相同的站点。 `stop_times.txt`. <br/>要在不提供任何实时到达或离开预测的情况下分配一个站点，请填入这个字段并设置 `StopTimeUpdate.schedule_relationship = NO_DATA`. <br/>如果这个字段被填充。 `StopTimeUpdate.stop_sequence`必须填入，而 `StopTimeUpdate.stop_id`不应被填充。站点分配也应反映在其他GTFS字段中（例如。 `VehiclePosition.stop_id`). <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |

## _消息_TripProperties

定义更新的行程属性

**注意：**这条消息仍然是**试验性的**，可能会有变化。它可能在未来被正式采用。<br/>。

**领域**

| _**字段名**_      | _**类型**_                                                              | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| -------------- | --------------------------------------------------------------------- | -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **trip_id**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 定义一个新旅程的标识符，它与(CSV)GTFS trips.txt中定义的现有旅程是重复的，但将在不同的服务日期和/或时间开始（用 `TripProperties.start_date`和 `TripProperties.start_time`).参见 `trips.trip_id`在(CSV)GTFS中的定义。它的值必须与（CSV）GTFS中使用的不同。这个字段是必须的，如果 `schedule_relationship`是 `DUPLICATED`, 否则这个字段必须不被填入，并被消费者忽略。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                                                                                                                                                         |
| **start_date** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 重复行程的服务日期。必须以YYYMMDD格式提供。这个字段是必须的，如果 `schedule_relationship`是 `DUPLICATED`, 否则这个字段必须不被填入，并被消费者忽略。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **start_time** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 定义重复行程时的出发开始时间。见定义 `stop_times.departure_time`在(CSV)GTFS中。重复的行程的预定到达和离开时间是根据原始行程和这个字段之间的偏移来计算的. `departure_time`和这个字段的偏移来计算。例如，如果一个GTFS旅程的A站有一个 `departure_time`的 `10:00:00`和B站为 `departure_time`的 `10:01:00`而这个字段被填入的值是 `10:30:00`这个字段被填入的值是，重复的行程中的B站将有一个预定的 `departure_time`的 `10:31:00`.实时预测 `delay`值被应用到这个计算的Schedule时间，以确定预测的时间。例如，如果提供B站的出发时间 `delay`的 `30`提供了B站的出发时间，那么预测的出发时间是 `10:31:30`.实时预测 `time`值没有应用任何偏移，并表示所提供的预测时间。  例如，如果提供的出发时间是 `time`代表10:31:30，那么预测的出发时间是 `10:31:30`.这个字段是必需的，如果 `schedule_relationship`是 `DUPLICATED`, 否则这个字段必须不被填入，并被消费者忽略。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |
| **shape_id**   | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 指定此行程的车辆行驶路径的形状，当它与原来的不同时。指的是在(CSV)GTFS中定义的形状或在实时信息中的一个新形状实体。见定义 `trips.shape_id`in (CSV)GTFS. <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

## _消息_VehiclePosition

一个给定车辆的Realtime定位信息。

**领域**

| _**字段名**_                 | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                          |
| ------------------------- | -------------------------------------------------------------------------- | -------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **行程**                    | [TripDescriptor](#message-tripdescriptor)                                  | 可选的      | 一        | 该车辆所服务的行程。如果车辆不能与给定的行程实例相识别，可以是空的或部分。                                                                                                                                                                                                                             |
| **车辆**                    | [车辆描述符](#message-vehicledescriptor)                                        | 可选的      | 一        | 关于为这个行程服务的车辆的额外信息。每个条目都应该有一个 **唯一的**车辆ID。                                                                                                                                                                                                                         |
| **位置**                    | [位置](#message-position)                                                    | 可选的      | 一        | 这个车辆的当前位置。                                                                                                                                                                                                                                                        |
| **current_stop_sequence** | [uint32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 当前站点的停车顺序索引。current_stop_sequence的含义（即它所指向的站点）由current_status决定。如果current_status丢失，则假定为IN_TRANSIT_TO。                                                                                                                                                             |
| **stop_id**               | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 可选的      | 一        | 识别当前的站点。该值必须与相应GTFS饲料中的stops.txt相同。如果 `StopTimeProperties.assigned_stop_id`用来指定一个 `stop_id`的变化，这个字段也应反映在 `stop_id`.                                                                                                                                               |
| **current_status**        | [车辆停靠状态](#enum-vehiclestopstatus)                                          | 可选的      | 一        | 车辆相对于当前站点的确切状态。如果current_stop_sequence丢失，则忽略。                                                                                                                                                                                                                     |
| **时间戳**                   | [uint64](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 测量车辆位置的时刻。以POSIX时间为单位（即从1970年1月1日00:00:00 UTC开始的秒数）。                                                                                                                                                                                                              |
| **拥挤程度**                  | [拥堵程度](#enum-congestionlevel)                                              | 可选的      | 一        |                                                                                                                                                                                                                                                                   |
| **占用状态**                  | [占用状态](#enum-occupancystatus)                                              | _可选的_    | 一        | 车辆或车厢的乘客占用状态。如果multi_carriage_details是用每节车厢的占用状态填充的，那么这个字段应该描述整个车辆，并考虑所有接受乘客的车厢。<br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                  |
| **占用率**                   | [uint32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 一个百分比值，表示车辆中的乘客占用程度。100这个值应该代表车辆设计的最大乘员总数，包括座位和站立的能力，以及目前的操作规定所允许的。如果有更多的乘客超过最大设计容量，该值可能超过100。占用率的精度应该足够低，以至于无法追踪到个别乘客的上车或下车情况。如果multi_carriage_details是用每节车厢的占用率填写的，那么这个字段应该描述整个车辆，并考虑所有接受乘客的车厢。<br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |
| **多节车厢细节**                | [车厢细节](#message-CarriageDetails)                                           | 可选的      | 许多       | 这个给定车辆的多个车厢的详细信息。第一次出现代表该车辆的第一节车厢。 **鉴于当前的旅行方向**.多车厢细节字段的出现次数代表该车辆的车厢数量。它还包括不可登机的车厢，如发动机、维修车厢等......因为它们为乘客提供了关于站台位置的宝贵信息。<br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                        |

## _enum_VehicleStopStatus

**价值**

| _**价值**_          | _**评论**_                     |
| ----------------- | ---------------------------- |
| **即将到达**          | 车辆即将到达车站（在车站显示屏上，车辆符号通常会闪烁）。 |
| **STOPPED_AT**    | 车辆正站在该站。                     |
| **IN_TRANSIT_TO** | 车辆已经离开了前一站，正在运输中。            |

## 拥堵等级（_enum_CongestionLevel

影响该车辆的拥堵级别。

**价值**

| _**价值**_                     |
| ---------------------------- |
| **unknown_congestion_level** |
| **顺利运行**                     |
| **停停走走**                     |
| **拥堵**                       |
| **严重拥堵**                     |

## _枚举 OccupancyStatus_

车辆或车厢的乘客占用状态。

个别生产者可能不会公布所有OccupancyStatus值。因此，消费者不能假设OccupancyStatus值遵循一个线性比例。消费者应该将OccupancyStatus值表示为生产者所指示和打算的状态。同样地，生产者必须使用与实际车辆占用状态相对应的OccupancyStatus值。

对于描述线性尺度上的乘客占有率水平，请参见`occupancy_percentage`。

**注意：**这个字段仍然是**试验性的**，可能会有变化。它可能会在未来被正式采用。

_**价值**_

| _**价值**_      | _**评论**_                                               |
| ------------- | ------------------------------------------------------ |
| _**EMPTY**_   | _该车被认为是空车，车上没有或很少有乘客，但仍在接受乘客。_                         |
| _**有许多座位**_   | _该车辆或车厢有大量的可用座位。在全部可用座位中，有多少空闲座位被认为大到可以归入这一类别，由生产者决定。_ |
| _**可用座位少**_   | _该车辆或车厢有少量可用的座位。在总的座位中，被认为足够小而属于这一类的空闲座位的数量，由制作者酌情决定。_ |
| _**仅有站立空间**_  | _该车辆或车厢目前只能容纳站立的乘客。_                                   |
| _**挤压的站立空间**_ | _该车辆或车厢目前只能容纳站立的乘客，而且空间有限。_                            |
| _**完整的**_     | _按照大多数的衡量标准，该车辆被认为是满的，但可能仍然允许乘客上车。_                    |
| _**不接受乘客**_   | _该车辆或车厢不接受乘客。该车辆或车厢通常接受乘客上车。_                          |
| _**没有数据**_    | _该车辆或车厢当时没有任何载客数据。_                                    |
| _**不可以登车**_   | _该车辆或车厢不能登车，从不接受乘客。对特殊车辆或车厢（发动机、维修车厢等......）有用。_       |

## _消息_CarriageDetails

马车的具体细节，用于由几个马车组成的车辆。

**注意：**该信息仍处于**试验阶段**，可能会发生变化。它可能会在未来被正式采用。

**领域**

| _**字段名**_ | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                                       |
| --------- | -------------------------------------------------------------------------- | -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **id**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 可选的      | 一        | 车厢的标识。每辆车应该是唯一的。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                                              |
| **标签**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 可选的      | 一        | 用户可见的标签，可以显示给乘客，帮助识别车厢。例如。"7712"，"ABC-32车厢"，等等。 <br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                    |
| **占用状态**  | [占用状态](#enum-occupancystatus)                                              | 可选的      | 一        | 在这个车辆中，这个给定的车厢的占用状态。默认设置为 `NO_DATA_AVAILABLE`.<br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                                                                 |
| **占用率**   | [int32](https://developers.google.com/protocol-buffers/docs/proto#scalar)  | 可选的      | 一        | 该车厢的占用率，在该车中的占用率。遵循与 "VehiclePosition.occupancy_percentage "相同的规则。如果没有这个车厢的数据，则使用-1。<br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                                                                           |
| **车厢_序列** | [uint32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 确定该车厢相对于车辆的车厢状态列表中的其他车厢的顺序。行进方向上的第一个车厢必须有1的值，第二个值对应于行进方向上的第二个车厢，必须有2的值，以此类推。例如，行进方向的第一节车厢的值为1，如果行进方向的第二节车厢的值为3，消费者将放弃所有车厢的数据（即多节车厢的细节字段）。没有数据的车厢必须用一个有效的车厢序列号来表示，没有数据的字段应该被省略（另外，这些字段也可以包括在内，并设置为 "没有数据 "的值）。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |

## _消息_警报

一个警报，表明公共交通网络中的某种事件。

**领域**

| _**字段名**_                  | _**类型**_                                    | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                    |
| -------------------------- | ------------------------------------------- | -------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **活动时间**                   | [时间范围](#message-timerange)                  | 可选的      | 许多       | 警报应该显示给用户的时间。如果缺失，只要警报出现在feed中，就会显示。如果给出多个范围，警报将在所有范围内显示。                                                                                                                                                   |
| **被通知的实体（informed_entity** | [EntitySelector](#message-entityselector)   | 需要       | 许多       | 我们应该通知其用户这个警报的实体。  必须提供至少一个informed_entity。                                                                                                                                                                 |
| **原因**                     | [原因](#enum-cause)                           | 可选的      | 一        |                                                                                                                                                                                                             |
| **效果**                     | [效果](#enum-effect)                          | 可选的      | 一        |                                                                                                                                                                                                             |
| **编码**                     | [翻译的字符串](#message-translatedstring)         | 可选的      | 一        | 提供关于该警报的额外信息的URL。                                                                                                                                                                                           |
| **header_text**            | [翻译的字符串](#message-translatedstring)         | 需要       | 一        | 警报的标题。这个纯文本字符串将被突出显示，例如用黑体字。                                                                                                                                                                                |
| **description_text**       | [翻译的字符串](#message-translatedstring)         | 需要       | 一        | 警报的描述。这个纯文本的字符串将被格式化为警报的主体（或者在用户明确的 "展开 "请求中显示）。描述中的信息应该添加到标题的信息中。                                                                                                                                          |
| **tts_header_text**        | [翻译的字符串](#message-translatedstring)         | 可选的      | 一        | 包含警报的标题的文本，用于文本到语音的实现。这个字段是header_text的文本到语音版本。它应该包含与header_text相同的信息，但格式化后可以作为文本到语音的读物（例如，去掉缩写，拼出数字，等等）。                                                                                                   |
| **tts_description_text**   | [翻译的字符串](#message-translatedstring)         | 可选的      | 一        | 包含对警报的描述的文本，用于文本到语音的实现。这个字段是description_text的文本到语音的版本。它应该包含与description_text相同的信息，但是格式化后可以作为文本到语音的读物（例如，去掉缩写，拼出数字，等等）。                                                                                      |
| **严重性_级别**                 | [严重程度等级（SeverityLevel](#enum-severitylevel) | 可选的      | 一        | 警报的严重程度。                                                                                                                                                                                                    |
| **图像**                     | [翻译后的图像](#message-translatedimage)          | 可选的      | 一        | 沿着警报文本显示的翻译图像。用来直观地解释绕行、车站关闭等的警报效果。图片应该加强对警报的理解，不能成为基本信息的唯一位置。不鼓励以下类型的图片：主要包含文字的图片，没有增加额外信息的营销或品牌图片。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                       |
| **图像_替代性文本**               | [翻译的字符串](#message-translatedstring)         | 可选的      | 一        | 描述链接的图像在该领域的外观的文本（例如，在该领域中）。 `image`字段中的链接图像的外观的文本（例如，在图像无法显示或用户因可访问性原因无法看到图像的情况下）。参见HTML [规范的alt图片文本](https://html.spec.whatwg.org/#alt). <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |

## _enum_Cause

该警报的原因。

**价值**

| _**价值**_          |
| ----------------- |
| **UNKNOWN_CAUSE** |
| **其他原因**          |
| **技术问题**          |
| **罢工**            |
| **示威**            |
| **事故**            |
| **假期**            |
| **气候**            |
| **维修**            |
| **建筑工程**          |
| **警务活动**          |
| **医疗急救**          |

## _枚举_效果

该问题对受影响实体的影响。

**价值**

| _**价值**_   |
| ---------- |
| **无服务**    |
| **服务减少**   |
| **重大延误**   |
| **迂回**     |
| **额外的服务**  |
| **修改后的服务** |
| **其他影响**   |
| **未知的影响**  |
| **停止移动**   |
| **无影响**    |
| **可访问性问题** |

## _enum_SeverityLevel

警报的严重程度。

**注意：**这个字段仍然是**试验性的**，可能会有变化。它可能会在未来被正式采用。

**价值**

| _**价值**_             |
| -------------------- |
| **unknown_severity** |
| **INFO**             |
| **警告**               |
| **严重的**              |

## _消息_时间范围

一个时间区间。如果`时间t`大于或等于开始时间，小于结束时间，则认为该时间间隔在时间`t`处于活动状态。

**领域**

| _**字段名**_ | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                             |
| --------- | -------------------------------------------------------------------------- | -------- | -------- | ---------------------------------------------------------------------------------------------------- |
| **开始**    | [uint64](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 开始时间，以POSIX时间为单位（即从1970年1月1日00:00:00 UTC开始的秒数）。如果缺少，则间隔时间从负无穷开始。  如果提供了一个时间范围，必须提供开始或结束，两个字段都不能为空。   |
| **结束**    | [uint64](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 结束时间，以POSIX时间为单位（即从1970年1月1日00:00:00 UTC起的秒数）。如果缺失，则时间间隔在正无穷大时结束。如果提供了一个时间范围，必须提供开始或结束时间--两个字段都不能为空。 |

## _信息_位置

车辆的一个地理位置。

**领域**

| _**字段名**_ | _**类型**_                                                               | _**需要**_ | _**心数**_ | _**说明**_                                                                                  |
| --------- | ---------------------------------------------------------------------- | -------- | -------- | ----------------------------------------------------------------------------------------- |
| **纬度**    | [浮动](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 北纬度，在WGS-84坐标系中。                                                                          |
| **经度**    | [浮动](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 东经度数，在WGS-84坐标系中。                                                                         |
| **方位**    | [浮动](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 方位，单位为度，从真北顺时针方向，即0为北，90为东。这可以是罗盘的方位，也可以是通往下一站或中间位置的方向。这不应该从以前的位置序列中推断出来，客户可以从以前的数据中计算出来。 |
| **路程表**   | [双重](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 路程表值，以米为单位。                                                                               |
| **速度**    | [浮动](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 车辆测量的瞬时速度，单位是米/秒。                                                                         |

## _消息_TripDescriptor

一个描述符，用于识别GTFS旅程的单一实例。

为了指定一个单独的行程实例，在许多情况下，一个`trip_id`本身就足够了。然而，下面的情况需要额外的信息来确定一个单独的旅程实例。

*   对于在frequencies.txt中定义的旅程，除了`trip_id`，还需要start\_`date`和`start_time`.
*   如果旅程持续超过24小时，或者延迟到与第二天的预定旅程相冲突，那么除了`trip_id`之外，还需要`start_date`。
*   如果不能提供`trip_id`字段，那么`route_id`，`方向_id`，`start_date`，和`start_time`都必须提供。

在所有的情况下，如果除了提供`trip_id`\_`route_id`之外，还提供route_id，那么`route_id`必须是GTFS trips.txt中分配给给定旅程的同一个`route_id`。

`trip_id`字段本身或与其他TripDescriptor字段结合，不能用来识别多个行程实例.例如，TripDescriptor不应该为GTFS frequencies.txtexact_times=0的旅程指定trip_id本身，因为start_time也需要解析为在一天中某个特定时间开始的单一旅程实例。如果TripDescriptor没有解析到一个行程实例（即，它解析到零个或多个行程实例），它被认为是一个错误，包含错误的TripDescriptor的实体可能被消费者丢弃。

注意，如果ttrip_id不知道，那么TripUpdate中的车站序列id是不够的，还必须提供stop_id。此外，必须提供绝对的到达/离开时间。

TripDescriptor.route_id不能在Alert EntitySelector中使用，以指定影响一条路线的所有车次的路线范围的警报--使用EntitySelector.route_id代替。

**领域**

| _**字段名**_      | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| -------------- | -------------------------------------------------------------------------- | -------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **trip_id**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 这个选择器所指的GTFS资料中的trip_id。对于非基于频率的旅程（未在GTFS frequencies.txt中定义的旅程），这个字段足以唯一地识别该旅程。对于在GTFS frequencies.txt中定义的基于频率的旅行，trip_id,start_time, 和 start_date都是必须的。对于基于计划的旅行（未在GTFS frequencies.txt中定义的旅行），只有当旅行可以由route_id，方向_id，start_time和开始日期的组合来唯一识别，并且所有这些字段都提供时，才可以省略行程trip_id。当TripUpdate中的schedule_relationship是duplicated时，trip_id标识了静态GTFS中要重复的旅程。当schedule_relationship在VehiclePosition中被DUPLICATED时，trip_id标识新的重复旅程，并且必须包含相应的TripUpdate.TripProperties.trip_id的值。                     |
| **route_id**   | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 这个选择器指的是GTFS中的route_id。如果trip_idid被省略，route_id，方向_id，start_time和schedule_relationship=SCHEDULED都必须被设置来识别一个旅程实例。TripDescriptor.route_id不应该被用在Alert EntitySelector中，来指定一个影响所有行程的路线范围内的警报--使用EntitySelector.route_id代替。                                                                                                                                                                                                                                                                     |
| **方向_id**      | [uint32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | GTFSfeedtrips.txt檔案中的direction_id，表示此選擇器所指的車程的方向。如果trip_id被省略，必须提供方向_id。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。<br/>                                                                                                                                                                                                                                                                                                                                           |
| **start_time** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 这个旅程实例的最初计划开始时间.当ttrip_id对应的是一个非基于频率的旅程时，这个字段应该被省略或者等于GTFS文件中的值。当trip_id对应于GTFS frequencies.txt中定义的基于频率的行程时，start_time是必需的，必须为行程更新和车辆位置指定。如果行程对应于exact_times=1条GTFS记录，那么start_time必须比frequencies.txt中相应时间段的start_time晚一些倍数(包括0)的headway_secs。如果行程对应exact_times=0，那么它的start_time可以是任意的，最初预计是该行程的第一个出发。一旦建立，这个基于频率的exact_times=0旅程的start_time应该被认为是不可改变的，即使第一次出发的时间改变了 -- 这个时间的改变可能会反映在StopTimeUpdate中。如果trip_id被省略，start_time必须被提供。这个字段的格式和语义与GTFSfrequencies.txt相同，例如，11:15:35或25:15:35。 |
| **start_date** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 这个旅程实例的开始日期，格式为YYYMMDD。对于预定行程（没有在GTFS frequencies.txt中定义的行程），这个字段必须被提供，以区分晚到与第二天预定行程相撞的行程。例如，对于每天8:00和20:00发车的列车，如果晚点12小时，就会有两个不同的班次在同一时间。这个字段可以提供，但对于不可能发生这种碰撞的时间表来说不是强制性的--例如，一个按小时运行的Schedule，车辆晚点一小时就不再被认为与Schedule有关。这个字段对于GTFS frequencies.txt中定义的基于频率的车次是必须的。如果trip_id被省略，必须提供start_date。                                                                                                                                                                                         |
| **计划关系**       | [时间安排关系](#enum-schedulerelationship-1)                                     | 可选的      | 一        | 这个行程和静态Schedule之间的关系。如果TripDescriptor被提供在Alert `EntitySelector`，该 `schedule_relationship`字段会被消费者在识别匹配的旅程实例时忽略.                                                                                                                                                                                                                                                                                                                                                                           |

## _enum_ScheduleRelationship

这个行程和静态Schedule之间的关系。如果一个行程是按照临时Schedule完成的，没有反映在GTFS中，那么它不应该被标记为SCHEDULED，而是标记为ADDED。

**价值**

| _**价值**_ | _**评论**_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **已安排**  | 正在按照其GTFS Schedule运行的行程，或者足够接近预定的行程而与之相关。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **增加**   | 一个额外的行程，是在运行Schedule之外增加的，例如，替换一个坏掉的车辆或应对突然的客运量。 _注意：目前，对于使用这种模式的馈送，行为是没有规定的。在GTFSGitHub上有一些讨论 [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221) [(3)](https://github.com/google/transit/pull/219)围绕着完全指定或废弃ADDED行程进行讨论，当这些讨论结束后，文档将被更新。_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| **未安排**  | 一个正在运行的旅程，没有与之相关的Schedule--这个值用来识别GTFS frequencies.txt中定义的确切时间=0的旅程。它不应该被用来描述GTFS frequencies.txtxt中没有定义的旅程，或者GTFS frequencies.txt中确切时间=1的旅程。带有 `schedule_relationship: UNSCHEDULED`的旅程也必须设置所有的StopTimeUpdates `schedule_relationship: UNSCHEDULED`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **取消的**  | 一个在Schedule中存在但被删除的旅程。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **重复的**  | 一个新的旅程，除了服务开始日期和时间外，与现有的计划旅程相同。使用时 `TripUpdate.TripProperties.trip_id`, `TripUpdate.TripProperties.start_date`, 和 `TripUpdate.TripProperties.start_time`一起使用，从静态GTFS中复制一个现有的行程，但是在不同的服务日期和/或时间开始。如果在(CSV)GTFS(在)中与原始旅程有关的服务，允许复制一个旅程。 `calendar.txt`或 `calendar_dates.txt`)在未来30天内运营。被复制的行程通过以下方式确定 `TripUpdate.TripDescriptor.trip_id`. <br/><br/>这个枚举并不修改现有的行程。 `TripUpdate.TripDescriptor.trip_id`- 如果生产者想取消原行程，它必须发布一个单独的 `TripUpdate`值为CANCELED。在GTFS中定义的旅行 `frequencies.txt`与 `exact_times`是空的或等于 `0`不能被重复。新行程的 `VehiclePosition.TripDescriptor.trip_id`中的值必须包含与之匹配的值. `TripUpdate.TripProperties.trip_id`和 `VehiclePosition.TripDescriptor.ScheduleRelationship`也必须被设置为 `DUPLICATED`.  <br/><br/>_现有的生产者和消费者使用ADDED枚举来表示重复的旅行，必须遵循 [迁移指南](https://github.com/google/transit/blob/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)来过渡到DUPLICATED 枚举。_ |

## _信息_VehicleDescriptor

执行行程的车辆的识别信息。

**领域**

| _**字段名**_ | _**类型**_                                                              | _**需要**_ | _**心数**_ | _**说明**_                                                               |
| --------- | --------------------------------------------------------------------- | -------- | -------- | ---------------------------------------------------------------------- |
| **id**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 车辆的内部系统标识。应该是 **唯一的**每辆车，用于跟踪车辆在系统中的运行情况。这个标识不应该对终端用户可见；为此，使用 **标签**字段 |
| **标签**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 用户可见的标签，也就是说，必须向乘客展示的东西，以帮助识别正确的车辆。                                    |
| **车牌**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 可选的      | 一        | 车辆的车牌。                                                                 |

## _消息_EntitySelector

GTFS馈送中的一个实体的选择器。字段的值应该对应于GTFS馈送中的适当字段。必须至少给出一个指定器。如果给了几个，它们应该被解释为由逻辑`和`运算符连接。 此外，指定者的组合必须与GTFS馈送中的相应信息相匹配。 换句话说，为了使警报适用于GTFS中的一个实体，它必须匹配所有提供的EntitySelector字段。 例如，一个EntitySelector包括字段`route_id`:"5" 和`route_type:"3 "`只适用于`route_id`:"`5 "`的公交车--它不适用任何其他route`_type`:`"3".` 如果生产者想让一个警报适用于`route_id`:"5 "以及`route`\_type:"`3"`，它应该提供两个单独的EntitySelectors，一个引用`route_id`:"5 "和另一个参考`route_type。"3".`

至少要给出一个指定项--EntitySelector中的所有字段不能为空。

**领域**

| _**字段名**_     | _**类型**_                                                                   | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                           |
| ------------- | -------------------------------------------------------------------------- | -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **agency_id** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 该选择器所指的GTFS馈送中的agency_id。                                                                                                                                          |
| **route_id**  | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 这个选择器所指的GTFS中的route_id。如果提供方向_id，也必须提供route_id。                                                                                                                    |
| **路线_类型**     | [int32](https://developers.google.com/protocol-buffers/docs/proto#scalar)  | 有条件要求    | 一        | 这个选择器所指的GTFS中的路由_类型。                                                                                                                                               |
| **方向_id**     | [uint32](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | 来自GTFSfeedtrips.txt文件的方向_，用于选择路线的一个方向的所有车次，由route_id 指定。如果提供方向_id，route_id也必须提供。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。<br/>             |
| **行程**        | [TripDescriptor](#message-tripdescriptor)                                  | 有条件要求    | 一        | 这个选择器指的是GTFS中的旅程实例。这个TripDescriptor必须解析为GTFS数据中的一个旅程实例(例如，生产者不能只为exact_times=0的旅程提供一个trip_id)。如果ScheduleRelationship字段在这个TripDescriptor中被填入，当消费者试图识别GTFS旅程时，它将被忽略。 |
| **stop_id**   | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar)      | 有条件要求    | 一        | 这个选择器所指的GTFS馈送中的stop_id。                                                                                                                                           |

## _消息_翻译字符串

一个国际化的消息，包含每个语言版本的文本片段或一个URL。消息中的一个字符串将被拾取。解析过程如下。如果用户界面language与某一翻译的language代码相匹配，则挑选第一个匹配的翻译。如果默认的用户界面language（例如，英语）与翻译的language代码相匹配，则挑选第一个匹配的翻译。如果某个翻译有一个未指定的language代码，则该翻译被选中。

**领域**

| _**字段名**_ | _**类型**_                   | _**需要**_ | _**心数**_ | _**说明**_    |
| --------- | -------------------------- | -------- | -------- | ----------- |
| **翻译**    | [译文](#message-translation) | 需要       | 许多       | 必须提供至少一个翻译。 |

## _消息_翻译

一个映射到language的本地化字符串。

| _**字段名**_    | _**类型**_                                                              | _**需要**_ | _**心数**_ | _**说明**_                                                                                             |
| ------------ | --------------------------------------------------------------------- | -------- | -------- | ---------------------------------------------------------------------------------------------------- |
| **文本**       | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 一个包含消息的UTF-8字符串。                                                                                     |
| **language** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | BCP-47language代码。如果language未知或对饲料完全不做国际化处理，则可以省略。最多允许一个翻译有一个未指定的language标签--如果有一个以上的翻译，必须提供language。 |

## _消息_TranslatedImage

一个国际化的消息，包含一个图像的每个语言版本。消息中的一个图像将被拾取。解决的过程如下。如果用户界面language与某一翻译的language代码相匹配，则挑选第一个匹配的翻译。如果默认的用户界面language（例如，英语）与翻译的language代码相匹配，则挑选第一个匹配的翻译。如果某些翻译有一个未指定的language代码，则挑选该翻译。

**注意：**该信息仍处于**试验阶段**，可能会发生变化。它可能会在未来被正式采用。

**领域**

| _**字段名**_ | _**类型**_                         | _**需要**_ | _**心数**_ | _**说明**_        |
| --------- | -------------------------------- | -------- | -------- | --------------- |
| **本地化图像** | [本地化图像](#message-localizedimage) | 需要       | 许多       | 必须提供至少一个本地化的图像。 |

## _消息_本地化图像

一个映射到某种language本地化图像URL。

| _**字段名**_      | _**类型**_                                                              | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                                                                                                                                                   |
| -------------- | --------------------------------------------------------------------- | -------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **编码**         | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 包含链接到图像的URL的字符串。链接的图像必须小于2MB。如果一个图像发生了足够大的变化，需要在消费者方面进行更新，生产者必须将URL更新为一个新的URL。<br/><br/>URL应该是一个完全合格的URL，包括http:// 或https://，URL中的任何特殊字符必须被正确转义。参见以下内容 [https://www.w3.org/Addressing/URL/4_URI_Recommentations.html](https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for)关于如何创建完全合格的URL值的描述。 |
| **media_type** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | IANA媒体类型，以指定要显示的图像类型。该类型必须以 "image/"开头                                                                                                                                                                                                                                                                     |
| **language**   | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 有条件要求    | 一        | BCP-47language代码。如果language未知或对饲料完全不做国际化处理，则可以省略。最多允许一个翻译有一个未指定的language标签--如果有一个以上的翻译，必须提供language。                                                                                                                                                                                                       |

## _消息_形状

描述当形状不是(CSV)GTFS的一部分时，车辆所走的物理路径，例如临时绕行。形状属于Trips，由一个编码的折线组成，以便更有效地传输。 形状不需要准确地截取站点的位置，但是一个行程中的所有站点应该位于该行程形状的一小段距离内，即接近连接形状点的直线段。

**注意：**这条消息仍然是**试验性的**，可能会有变化。它可能在未来被正式采用。<br/>。

**领域**

| _**字段名**_    | _**类型**_                                                              | _**需要**_ | _**心数**_ | _**说明**_                                                                                                                                                                               |
| ------------ | --------------------------------------------------------------------- | -------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **shape_id** | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 形状的标识符。必须不同于任何 `shape_id`在(CSV)GTFS中定义。 <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。                                                                               |
| **编码的折线**    | [弦](https://developers.google.com/protocol-buffers/docs/proto#scalar) | 需要       | 一        | 形状的编码折线表示。这条折线必须至少包含两个点。关于编码的折线的更多信息，见 <https://developers.google.com/maps/documentation/utilities/polylinealgorithm> <br/><br/>**注意事项。**此字段仍是 **实验性**它可能在未来被正式采用，并且会有变化。它可能会在未来被正式采用。 |
